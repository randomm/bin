#!/usr/bin/env zsh
# ytclip - Extract precise audio clips from YouTube videos
# Author: Janni Turunen
# License: MIT
# Version: 0.2.0

set -euo pipefail

# Default values
BITRATE="128k"
FADE_IN="2"
FADE_OUT="2"
OUTPUT_DIR="."
BUFFER_SECONDS=10
CLEANUP=true
TEMP_FADED_BASE=""
OUTPUT_BASENAME=""
OUTPUT_DIRNAME=""

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to display help
show_help() {
    cat << EOF
ytclip - Extract precise audio clips from YouTube videos

USAGE:
    ytclip URL [START END] [OPTIONS]
    ytclip --help

ARGUMENTS:
    URL                YouTube video URL
    START              Start timestamp (format: MM:SS or HH:MM:SS) [optional]
    END                End timestamp (format: MM:SS or HH:MM:SS) [optional - required if START provided]

OPTIONS:
    -o, --output NAME  Output filename (default: generated from video title)
    -d, --dir DIR      Output directory (default: current directory)
    -b, --bitrate BR   MP3 bitrate in kbps (default: 128)
    -f, --fade-in SEC  Fade in duration in seconds (default: 2)
    -F, --fade-out SEC Fade out duration in seconds (default: 2)
    --no-fade          Disable both fade effects
    --keep-temp        Keep temporary files (for debugging)
    --cookies FILE     Path to cookies file for authentication
    --cookies-browser  Extract cookies from browser (chrome/firefox/safari)
    -h, --help         Show this help message

EXAMPLES:
    # Download entire video as MP3
    ytclip "https://youtube.com/watch?v=..."

    # Basic usage with timestamps
    ytclip "https://youtube.com/watch?v=..." 2:40 3:20

    # Custom output name and bitrate
    ytclip "https://youtube.com/watch?v=..." 1:30 2:45 -o "my_clip.mp3" -b 192

    # No fade effects, custom directory
    ytclip "https://youtube.com/watch?v=..." 0:45 1:30 --no-fade -d ~/Music/clips

    # Longer fade effects
    ytclip "https://youtube.com/watch?v=..." 2:00 4:00 -f 3 -F 5

NOTES:
    - The script downloads a wider section to handle YouTube's segment boundaries,
      then uses ffmpeg for precise cutting at the exact timestamps you specify.
    - Requires yt-dlp and ffmpeg to be installed.
    - Output format is MP3 with configurable bitrate.

EOF
}

# Function to print colored messages
print_error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}‚úì $1${NC}"
}

print_info() {
    echo -e "${YELLOW}‚Üí $1${NC}"
}

# Function to check dependencies
check_dependencies() {
    local deps_missing=false
    
    if ! command -v yt-dlp &> /dev/null; then
        print_error "yt-dlp is not installed. Install with: brew install yt-dlp"
        deps_missing=true
    fi
    
    if ! command -v ffmpeg &> /dev/null; then
        print_error "ffmpeg is not installed. Install with: brew install ffmpeg"
        deps_missing=true
    fi
    
    if [[ "$deps_missing" == true ]]; then
        exit 1
    fi
}

# Function to convert timestamp to seconds
timestamp_to_seconds() {
    local ts="$1"
    local parts=(${(s/:/)ts})
    local seconds=0
    
    if [[ ${#parts[@]} -eq 2 ]]; then
        # MM:SS format
        seconds=$((${parts[1]} * 60 + ${parts[2]}))
    elif [[ ${#parts[@]} -eq 3 ]]; then
        # HH:MM:SS format
        seconds=$((${parts[1]} * 3600 + ${parts[2]} * 60 + ${parts[3]}))
    else
        print_error "Invalid timestamp format: $ts (use MM:SS or HH:MM:SS)"
        exit 1
    fi
    
    echo $seconds
}

# Function to convert seconds to timestamp format
format_seconds() {
    local total_seconds=$1
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))
    
    if [[ $hours -gt 0 ]]; then
        printf "%d:%02d:%02d" $hours $minutes $seconds
    else
        printf "%d:%02d" $minutes $seconds
    fi
}

# Function to sanitize filename
sanitize_filename() {
    local filename="$1"
    local max_length=${2:-100}  # Default max length 100 chars
    
    # Try iconv for character conversion first if available (more reliable)
    if command -v iconv &> /dev/null; then
        filename=$(echo "$filename" | iconv -t ascii//TRANSLIT 2>/dev/null || echo "$filename")
    fi
    
    # Manual conversion for common special characters as fallback
    filename=$(echo "$filename" | sed 's/√§/ae/g; s/√∂/oe/g; s/√º/ue/g; s/√Ñ/Ae/g; s/√ñ/Oe/g; s/√ú/Ue/g')
    filename=$(echo "$filename" | sed 's/√ü/ss/g; s/√©/e/g; s/√®/e/g; s/√™/e/g; s/√´/e/g')
    filename=$(echo "$filename" | sed 's/√°/a/g; s/√†/a/g; s/√¢/a/g; s/√£/a/g; s/√•/a/g')
    filename=$(echo "$filename" | sed 's/√≠/i/g; s/√¨/i/g; s/√Æ/i/g; s/√Ø/i/g')
    filename=$(echo "$filename" | sed 's/√≥/o/g; s/√≤/o/g; s/√¥/o/g; s/√µ/o/g; s/√∏/o/g')
    filename=$(echo "$filename" | sed 's/√∫/u/g; s/√π/u/g; s/√ª/u/g')
    filename=$(echo "$filename" | sed 's/√Ω/y/g; s/√ø/y/g; s/√±/n/g; s/√ß/c/g')
    
    # Replace filesystem-unsafe characters with underscores
    filename=$(echo "$filename" | tr '/\\:*?"<>|' '_')
    
    # Replace spaces and other problematic chars with underscores
    filename=$(echo "$filename" | tr ' +&()[]{}' '_')
    
    # Collapse multiple underscores into single underscores
    filename=$(echo "$filename" | sed 's/_\+/_/g')
    
    # Remove leading/trailing underscores and dots
    filename=$(echo "$filename" | sed 's/^[_.]*//; s/[_.]*$//')
    
    # Truncate if too long, but preserve extension if present
    if [[ ${#filename} -gt $max_length ]]; then
        if [[ "$filename" =~ \.[a-zA-Z0-9]+$ ]]; then
            # Has extension - preserve it
            local ext="${filename##*.}"
            local base="${filename%.*}"
            local available=$((max_length - ${#ext} - 1))
            if [[ $available -gt 0 ]]; then
                filename="${base:0:$available}.${ext}"
            else
                # If extension is too long, just truncate everything
                filename="${filename:0:$max_length}"
            fi
        else
            # No extension - simple truncation
            filename="${filename:0:$max_length}"
        fi
    fi
    
    # Ensure it's not empty
    if [[ -z "$filename" ]]; then
        filename="audio_clip"
    fi
    
    echo "$filename"
}

# Function to clean up temp files
cleanup() {
    if [[ "$CLEANUP" == true ]]; then
        print_info "Cleaning up temporary files..."
        
        # Clean up any temporary files that might have been created
        if [[ -n "${TEMP_FADED_BASE:-}" ]]; then
            rm -f "$TEMP_FADED_BASE" "${TEMP_FADED_BASE}_faded.mp3"
        fi
        
        # Clean up potential temporary files from previous runs
        if [[ -n "${TEMP_BASE:-}" ]]; then
            rm -f "${TEMP_BASE}.mp3" "${TEMP_BASE}.m4a" "${TEMP_BASE}.webm" "${TEMP_BASE}.mp4" \
                  "${TEMP_BASE}.mp3.part" "${TEMP_BASE}.m4a.part" "${TEMP_BASE}.webm.part" "${TEMP_BASE}.mp4.part" \
                  "${TEMP_BASE}.mp3.ytdl" "${TEMP_BASE}.m4a.ytdl" "${TEMP_BASE}.webm.ytdl" "${TEMP_BASE}.mp4.ytdl"
        fi
    fi
}

# Set up trap for cleanup
trap cleanup EXIT INT TERM

# Function to generate unique filename by appending numbers
generate_unique_filename() {
    local base_path="$1"
    local counter=1
    local new_path="$base_path"
    
    # If file exists, try appending numbers until we find a unique name
    while [[ -f "$new_path" ]]; do
        # Extract directory, filename, and extension
        local dir=$(dirname "$base_path")
        local filename=$(basename "$base_path")
        local extension=""
        local name_without_ext="$filename"
        
        # Check if file has an extension
        if [[ "$filename" == *.* ]]; then
            extension=".${filename##*.}"
            name_without_ext="${filename%.*}"
        fi
        
        # Generate new filename with counter
        new_path="${dir}/${name_without_ext}_${counter}${extension}"
        counter=$((counter + 1))
    done
    
    echo "$new_path"
}

# Parse arguments
if [[ $# -lt 1 ]]; then
    show_help
    exit 1
fi

if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_help
    exit 0
fi

if [[ $# -lt 1 ]]; then
    print_error "Missing required arguments"
    echo "Usage: ytclip URL [START END] [OPTIONS]"
    echo "Try 'ytclip --help' for more information."
    exit 1
fi

URL="$1"
START_TIME=""
END_TIME=""

# Check if we have timestamps
if [[ $# -ge 3 && "$2" =~ ^[0-9]+:[0-9]+(:[0-9]+)?$ ]]; then
    if [[ $# -lt 3 ]]; then
        print_error "If START time is provided, END time is also required"
        echo "Usage: ytclip URL [START END] [OPTIONS]"
        echo "Try 'ytclip --help' for more information."
        exit 1
    fi
    START_TIME="$2"
    END_TIME="$3"
    shift 3
else
    shift 1
fi

OUTPUT_FILE=""
COOKIES_FILE=""
COOKIES_BROWSER=""

# Parse optional arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -d|--dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -b|--bitrate)
            BITRATE="${2}k"
            shift 2
            ;;
        -f|--fade-in)
            FADE_IN="$2"
            shift 2
            ;;
        -F|--fade-out)
            FADE_OUT="$2"
            shift 2
            ;;
        --no-fade)
            FADE_IN="0"
            FADE_OUT="0"
            shift
            ;;
        --keep-temp)
            CLEANUP=false
            shift
            ;;
        --cookies)
            COOKIES_FILE="$2"
            shift 2
            ;;
        --cookies-browser)
            COOKIES_BROWSER="$2"
            shift 2
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Try 'ytclip --help' for more information."
            exit 1
            ;;
    esac
done

# Check dependencies
check_dependencies

# Build cookie parameters for yt-dlp
COOKIE_ARGS=()
if [[ -n "$COOKIES_FILE" ]]; then
    COOKIE_ARGS+=(--cookies "$COOKIES_FILE")
    print_info "Using cookies from file: $COOKIES_FILE"
elif [[ -n "$COOKIES_BROWSER" ]]; then
    COOKIE_ARGS+=(--cookies-from-browser "$COOKIES_BROWSER")
    print_info "Extracting cookies from browser: $COOKIES_BROWSER"
fi

# Validate and normalize URL
if [[ ! "$URL" =~ ^https?://(www\.)?(youtube\.com/(watch\?.*v=|live/|embed/|v/|shorts/)|youtu\.be/) ]]; then
    print_error "Invalid YouTube URL format"
    exit 1
fi

# Store original URL for live stream detection
ORIGINAL_URL="$URL"

# Convert live URLs to standard watch URLs for better compatibility  
if [[ "$URL" =~ "youtube.com/live/" ]]; then
    VIDEO_ID=$(echo "$URL" | sed 's/.*\/live\///; s/[?&].*//')
    URL="https://www.youtube.com/watch?v=${VIDEO_ID}"
    print_info "Converted live stream URL to standard format for better extraction"
    print_info "Original: $ORIGINAL_URL"
    print_info "Using: $URL"
elif [[ "$URL" =~ "youtu.be/" ]]; then
    VIDEO_ID=$(echo "$URL" | sed 's/.*youtu.be\///; s/[?&].*//')
    URL="https://www.youtube.com/watch?v=${VIDEO_ID}"
    print_info "Converted short URL to standard format"
    print_info "Using: $URL"
fi

# Convert timestamps to seconds if provided
if [[ -n "$START_TIME" && -n "$END_TIME" ]]; then
    START_SEC=$(timestamp_to_seconds "$START_TIME")
    END_SEC=$(timestamp_to_seconds "$END_TIME")
    DURATION=$((END_SEC - START_SEC))
    
    if [[ $DURATION -le 0 ]]; then
        print_error "End time must be after start time"
        exit 1
    fi
    
    # Validate fade durations
    if [[ $(($FADE_IN + $FADE_OUT)) -ge $DURATION ]]; then
        print_error "Combined fade durations exceed clip duration"
        exit 1
    fi
    CLIP_MODE=true
else
    CLIP_MODE=false
fi

# Create output directory if needed
if [[ ! -d "$OUTPUT_DIR" ]]; then
    mkdir -p "$OUTPUT_DIR"
fi

# Get video info if output name not specified or for duration check
if [[ -z "$OUTPUT_FILE" ]] || [[ "$CLIP_MODE" == false ]]; then
    print_info "Fetching video information..."
    VIDEO_TITLE_RAW=$(yt-dlp --get-title "$URL" 2>/dev/null)
    
    # Get video duration to warn about long videos
    if [[ "$CLIP_MODE" == false ]]; then
        VIDEO_DURATION_STR=$(yt-dlp --get-duration "$URL" 2>/dev/null)
        if [[ -n "$VIDEO_DURATION_STR" ]]; then
            # Parse duration and convert to seconds for comparison
            if [[ "$VIDEO_DURATION_STR" =~ ^([0-9]+):([0-9]+):([0-9]+)$ ]]; then
                # HH:MM:SS format
                VIDEO_DURATION_SEC=$((${match[1]} * 3600 + ${match[2]} * 60 + ${match[3]}))
            elif [[ "$VIDEO_DURATION_STR" =~ ^([0-9]+):([0-9]+)$ ]]; then
                # MM:SS format
                VIDEO_DURATION_SEC=$((${match[1]} * 60 + ${match[2]}))
            else
                VIDEO_DURATION_SEC=0
            fi
            
            # Warn if video is longer than 30 minutes (1800 seconds)
            if [[ $VIDEO_DURATION_SEC -gt 1800 ]]; then
                echo -e "${YELLOW}‚ö†Ô∏è  Warning: This video is ${VIDEO_DURATION_STR} long and will take significant time to download.${NC}"
                echo -e "${YELLOW}   Consider specifying start/end timestamps to extract just the segment you need.${NC}"
                echo -e "${YELLOW}   Continuing with full video download automatically (no interactive prompts in non-interactive mode).${NC}"
            fi
        fi
    fi
    
    if [[ -z "$OUTPUT_FILE" ]]; then
        VIDEO_TITLE=$(sanitize_filename "$VIDEO_TITLE_RAW" 80)  # Limit to 80 chars for base name
        if [[ "$CLIP_MODE" == true ]]; then
            TIMESTAMP_SUFFIX="_${START_TIME//:/}-${END_TIME//:/}"
            OUTPUT_FILE="${VIDEO_TITLE}${TIMESTAMP_SUFFIX}.mp3"
        else
            OUTPUT_FILE="${VIDEO_TITLE}.mp3"
        fi
    fi
fi

# Sanitize user-provided filename if needed
if [[ -n "$OUTPUT_FILE" ]]; then
    OUTPUT_FILE=$(sanitize_filename "$OUTPUT_FILE" 120)
fi

# Ensure .mp3 extension
if [[ ! "$OUTPUT_FILE" =~ \.mp3$ ]]; then
    OUTPUT_FILE="${OUTPUT_FILE}.mp3"
fi

FULL_OUTPUT_PATH="${OUTPUT_DIR}/${OUTPUT_FILE}"

# Calculate download parameters based on mode
if [[ "$CLIP_MODE" == true ]]; then
    # Calculate download range with buffer for clipping
    DOWNLOAD_START=$((START_SEC - BUFFER_SECONDS))
    if [[ $DOWNLOAD_START -lt 0 ]]; then
        DOWNLOAD_START=0
        BUFFER_ADJUSTMENT=$START_SEC
    else
        BUFFER_ADJUSTMENT=$BUFFER_SECONDS
    fi
    DOWNLOAD_END=$((END_SEC + BUFFER_SECONDS))
    
    # Convert back to timestamp format for yt-dlp
    DOWNLOAD_START_TS=$(format_seconds $DOWNLOAD_START)
    DOWNLOAD_END_TS=$(format_seconds $DOWNLOAD_END)
fi



# Main extraction logic
if [[ "$CLIP_MODE" == true ]]; then
    print_info "Extracting audio segment ($START_TIME to $END_TIME)..."
    
    # Generate unique filename automatically (no user interaction)
    FULL_OUTPUT_PATH=$(generate_unique_filename "$FULL_OUTPUT_PATH")
    
    # Calculate precise duration in seconds for the clip
    DURATION_SECONDS=$DURATION
    
    # Use the PROVEN extraction method with external downloader for precise extraction
    print_info "Using optimized extraction method..."
    
    # Format the timestamps properly with leading zeros if needed
    FORMATTED_START_TIME=$(printf "%02d:%02d:%02d" $((START_SEC/3600)) $(((START_SEC%3600)/60)) $((START_SEC%60)))
    FORMATTED_DURATION=$(printf "%02d:%02d:%02d" $((DURATION_SECONDS/3600)) $(((DURATION_SECONDS%3600)/60)) $((DURATION_SECONDS%60)))
    
    if yt-dlp --quiet --no-warnings \
        "${COOKIE_ARGS[@]}" \
        --external-downloader ffmpeg \
        --external-downloader-args "ffmpeg_i:-ss $FORMATTED_START_TIME -t $FORMATTED_DURATION" \
        -x --audio-format mp3 --audio-quality "${BITRATE%k}" \
        --force-overwrites \
        "$URL" -o "$FULL_OUTPUT_PATH"; then
        
        # Give a small delay to ensure file is fully written
        sleep 1
        
        # Verify the output file was created successfully
        if [[ -f "$FULL_OUTPUT_PATH" ]] && [[ -s "$FULL_OUTPUT_PATH" ]]; then
            print_success "Audio segment extracted successfully!"
            
            # Apply fade effects if needed
            if [[ "$FADE_IN" != "0" ]] || [[ "$FADE_OUT" != "0" ]]; then
                print_info "Applying fade effects..."
                TEMP_FADED_BASE=$(mktemp)
                TEMP_FADED="${TEMP_FADED_BASE}_faded.mp3"
                
                # Build fade filter
                FADE_FILTERS=""
                if [[ "$FADE_IN" != "0" ]]; then
                    FADE_FILTERS="afade=in:d=${FADE_IN}"
                fi
                if [[ "$FADE_OUT" != "0" ]]; then
                    FADE_OUT_START=$((DURATION_SECONDS - FADE_OUT))
                    if [[ -n "$FADE_FILTERS" ]]; then
                        FADE_FILTERS="${FADE_FILTERS},afade=out:st=${FADE_OUT_START}:d=${FADE_OUT}"
                    else
                        FADE_FILTERS="afade=out:st=${FADE_OUT_START}:d=${FADE_OUT}"
                    fi
                fi
                
                if ffmpeg -nostdin -hide_banner -loglevel error -i "$FULL_OUTPUT_PATH" -af "$FADE_FILTERS" -c:a libmp3lame -b:a "$BITRATE" "$TEMP_FADED" 2>/dev/null; then
                    # Verify the faded file was created successfully
                    if [[ -f "$TEMP_FADED" ]] && [[ -s "$TEMP_FADED" ]]; then
                        mv "$TEMP_FADED" "$FULL_OUTPUT_PATH"
                        print_success "Fade effects applied"
                    else
                        print_error "Failed to create faded output file"
                        print_error "Keeping original file without fade effects"
                    fi
                    rm -f "$TEMP_FADED_BASE" 2>/dev/null
                else
                    rm -f "$TEMP_FADED_BASE" "$TEMP_FADED" 2>/dev/null
                    print_error "Failed to apply fade effects, keeping original"
                fi
            fi
        else
            print_error "Downloaded file does not exist or is empty"
            print_error "Try: --cookies-browser chrome for unlisted videos"
            exit 1
        fi
    else
        print_error "Failed to extract audio segment"
        print_error "Try: --cookies-browser chrome for unlisted videos"
        exit 1
    fi

else
    # Full video download
    print_info "Downloading complete video as MP3..."
    
    # Generate unique filename automatically (no user interaction)
    FULL_OUTPUT_PATH=$(generate_unique_filename "$FULL_OUTPUT_PATH")
    
    if yt-dlp --quiet --no-warnings \
        "${COOKIE_ARGS[@]}" \
        -x --audio-format mp3 --audio-quality "${BITRATE%k}" \
        --force-overwrites \
        "$URL" -o "$FULL_OUTPUT_PATH" 2>/dev/null; then
        # Give a small delay to ensure file is fully written
        sleep 1
        # Verify the output file was created successfully
        if [[ -f "$FULL_OUTPUT_PATH" ]] && [[ -s "$FULL_OUTPUT_PATH" ]]; then
            print_success "Full video audio extracted successfully!"
        else
            print_error "Download completed but output file does not exist or is empty"
            exit 1
        fi
    else
        print_error "Failed to download audio from YouTube"
        exit 1
    fi
fi

print_success "Processing complete!"

# Print summary
echo ""
echo "üìÑ Output file: $FULL_OUTPUT_PATH"
if [[ "$CLIP_MODE" == true ]]; then
    echo "‚è±  Duration: ${DURATION} seconds"
    echo "üéµ Bitrate: $BITRATE"
    if [[ "$FADE_IN" != "0" ]] || [[ "$FADE_OUT" != "0" ]]; then
        echo "üéö  Fade: ${FADE_IN}s in, ${FADE_OUT}s out"
    fi
else
    echo "üéµ Bitrate: $BITRATE"
    echo "üì∫ Mode: Full video download"
fi

# Get file size
if [[ -f "$FULL_OUTPUT_PATH" ]]; then
    FILE_SIZE=$(du -h "$FULL_OUTPUT_PATH" | cut -f1)
    echo "üíæ File size: $FILE_SIZE"
fi

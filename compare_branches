#!/bin/zsh

# Function to print in color
print_color() {
    local color=$1
    local text=$2
    case $color in
        "red") echo "\033[31m$text\033[0m";;
        "green") echo "\033[32m$text\033[0m";;
        "yellow") echo "\033[33m$text\033[0m";;
        "blue") echo "\033[34m$text\033[0m";;
        "magenta") echo "\033[35m$text\033[0m";;
        "cyan") echo "\033[36m$text\033[0m";;
        "white") echo "\033[37m$text\033[0m";;
        "bold") echo "\033[1m$text\033[0m";;
        *) echo "$text";;
    esac
}

# Function to create clickable links
create_link() {
    local text=$1
    local url=$2
    echo "\033]8;;$url\033\\$text\033]8;;\033\\"
}

# Function to check if a commit is a merge commit and output a link to GitHub
check_merge_commit() {
    local commit_hash=$1
    local repo_url=$2
    local commit_url="$repo_url/commit/$commit_hash"
    if git show --no-patch --pretty=%P $commit_hash | grep -q ' '; then
        echo "$(print_color 'yellow' "$commit_hash") is a merge commit - $(create_link 'View Commit' $commit_url)"
    else
        echo "$(print_color 'cyan' "$commit_hash") is not a merge commit - $(create_link 'View Commit' $commit_url)"
    fi
}

# Function to list commits unique to a branch
list_unique_commits() {
    local base_branch=$1
    local compare_branch=$2
    local repo_url=$3
    local output_file=$4

    echo "$(print_color 'bold' "Commits in $compare_branch not in $base_branch:")" > $output_file
    git cherry $base_branch $compare_branch | grep '^+' | cut -d ' ' -f 2 | while read commit; do
        check_merge_commit $commit $repo_url >> $output_file
    done
}

# Verbose flag
verbose=0

# Check for the -v flag
if [ "$1" = "-v" ]; then
    verbose=1
    shift
fi

# Check if two branch names are provided
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 [-v] <branch1> <branch2>"
    exit 1
fi

branch1=$1
branch2=$2

# Fetch the repository URL from .git/config
repo_url=$(git config --get remote.origin.url | sed -e 's/git@github.com:/https:\/\/github.com\//' -e 's/\.git$//')

# Fetch the latest changes
if [ $verbose -eq 1 ]; then
    echo "$(print_color 'blue' 'Fetching the latest changes...')"
    git fetch origin
else
    git fetch origin > /dev/null 2>&1
fi

# Checkout the branches and pull the latest changes
if [ $verbose -eq 1 ]; then
    echo "$(print_color 'blue' "Checking out and pulling latest changes for $branch1...")"
    git checkout $branch1
    git pull origin $branch1
else
    git checkout $branch1 > /dev/null 2>&1
    git pull origin $branch1 > /dev/null 2>&1
fi

if [ $verbose -eq 1 ]; then
    echo "$(print_color 'blue' "Checking out and pulling latest changes for $branch2...")"
    git checkout $branch2
    git pull origin $branch2
else
    git checkout $branch2 > /dev/null 2>&1
    git pull origin $branch2 > /dev/null 2>&1
fi

# List unique commits in each branch
if [ $verbose -eq 1 ]; then
    echo "$(print_color 'blue' "Listing unique commits in $branch2 not in $branch1...")"
fi
list_unique_commits $branch1 $branch2 $repo_url "unique_to_$branch2.txt"

if [ $verbose -eq 1 ]; then
    echo "$(print_color 'blue' "Listing unique commits in $branch1 not in $branch2...")"
fi
list_unique_commits $branch2 $branch1 $repo_url "unique_to_$branch1.txt"

# Display results
echo "$(print_color 'bold' '==================================================')"
echo "$(print_color 'bold' 'Results:')"
cat "unique_to_$branch2.txt"
echo "$(print_color 'bold' '--------------------------------------------------')"
cat "unique_to_$branch1.txt"
echo "$(print_color 'bold' '==================================================')"

# Cleanup
rm "unique_to_$branch2.txt"
rm "unique_to_$branch1.txt"
